## Глава - 16, Задание - 9 

По сравнению с массивом связный список отличается более простым
добавлением и удалением элементов, но медленной сортировкой. Поэтому возникает
вопрос: возможно, было бы быстрее скопировать список в массив, отсортировать
массив и скопировать отсортированный результат обратно в список, чем просто
использовать алгоритм списка для сортировки. (Но это может быть связано с
наличием большего объема памяти.) Проверьте гипотезу о более быстром
выполнении задачи, применив следующий подход.

*а.* - Создайте большой объект ***ѵі0*** типа ***vector<int>***, используя ***rand()*** для
задания начальных значений.

*б.* - Создайте второй объект ***ѵі*** типа ***vector<int>*** и объект ***1і*** типа ***list<int>***
того же размера, что и исходный, и инициализируйте их значениями
исходного вектора.

*в.* - Замерьте время, требуемое программе для сортировки ***ѵі*** с помощью
алгоритма ***sort()*** из ***STL***, а затем время, необходимое для сортировки ***1і***
посредством метода ***list*** ***sort()***.

*г.* - Переустановите ***1і*** неотсортированным содержимым ѵіО. Замерьте время
выполнения смешанной операции копирования ***1і*** в ***ѵі***, сортировки ***ѵі*** и
копирования результата обратно в ***1і***.

Для измерения времени выполнения этих операций можно использовать
***clock()*** из библиотеки ***ctime***. Как показано в листинге ***5.14***, для запуска
первого таймера можно применять следующий оператор:

```objectivec
clock_t start = clock();
```

Для получения прошедшего времени в конце операции используйте следующий
оператор:

```objectivec
clock_t end = clock();
cout << (double)(end - start)/CLOCKS_PER_SEC;
```

Вне всяких сомнений, этот тест показателен, поскольку результаты будут
зависеть от ряда факторов, в том числе объема доступной памяти, применения
многопроцессорной обработки и размеров массива или списка. (С
увеличением количества сортируемых элементов можно ожидать большего увеличения
эффективности массива по сравнению со списком.) Кроме того, при наличии
выбора между стандартной сборкой и окончательной сборкой, следует
выбирать окончательную сборку. В современных высокоскоростных компьютерах
для получения репрезентативных результатов необходимо использовать массив
максимально возможного размера. Например, можно иметь 100 000, 1 000 000 и
10 000 000 элементов.
